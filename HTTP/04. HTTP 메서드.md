# HTTP 메서드



## HTTP API 를 만들어보자

### 요구사항

**회원 정보 관리 API** 를 만든다고 가정했을때 아래의 기능이 필요하다고 가정

* 회원 목록 조회
* 회원 조회
* 회원 등록
* 회원 수정
* 회원 삭제



### API URI 고민 (Uniform Interface Identifier)

**리소스 식별자** 가 가장 중요

* 리소스의 의미는 뭘까?
  * 회원을 등록하고 수정, 조회하는게 리소스가 아니다.
  * 여기서는 **회원**이라는 개념 자체가 **리소스**
* 리소스를 어떻게 식별하는게 좋을까?
  * 회원을 등록 수정, 조회 하는것은 모두 배제
  * **회원이라는 리소스만 식별하면 된다.** 회원 리소스를 URI에 매핑



### 리소스와 행위를 분리

**가장 중요한 것은 리소스를 식별하는 것!**

* URI는 **리소스만 식별할 수 있으면 됌**
* **리소스**와 해당 리소스를 대상으로하는 **행위**를 분리
  * 리소스 : 회원
  * 행위 : 조회, 등록, 삭제, 변경 등
* 리소스는 명사, 행위는 동사
* 행위는 어떻게 구분하나 ?? 바로 다음 내용인 HTTP 메서드인 GET, POST를 이용한다



## HTTP 메서드 GET, POST

### 주요 메서드

* GET : 리소스 조회
* POST : 요청 데이터 처리, 주로 등록에 사용
* PUT : 리소스를 대체, 해다 리소스가 없으면 생성
* PATCH : 리소스 부분 변경
* DELETE : 리소스 삭제



### GET

```HTTP
GET /search?q=hello&hl=ko HTTP/1.1
Host: www.google.com
```

* 리로스 조회
* 서버에 전달하고 싶은 데이터는 query (쿼리 파라미터, 쿼리 스트링)를 통해서 전달
* 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음



#### 리소스 조회 1 - 메시지 전달

```HTTP
GET /members/100 HTTP/1.1
Host: localhost:8080
```

#### 리소스 조회 2 - 서버 도착

```json
// /members/100
{
  "username": "young",
  "age": 20
}
```

#### 리소스 조회 3 - 응답 데이터

```HTTP
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 34

{
	"username": "young",
	"age": 20
}
```



### POST

* 요청 데이터 처리
* 클라이언트에서 **메시지 바디를 통해 서버로 요청 데이터를 전달**
* 서버는 요청 데이터를 **처리**
  * 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다. 
* 주로 전달된 데이터로 **신규 리소스 등록**, **프로세스 처리**에 사용



#### 리소스 등록1 - 메시지 전달

```HTTP
POST /members HTTP/1.1
Content-Type: application/json

{
	"username": "young",
	"age": 20
}
```



#### 리소스 등록2 - 신규 리소스 생성

```json
// /members/100 --> 100번째에 생성

{
	"username": "young",
	"age": 20
}
```



#### 리소스 등록3 - 응답 데이터

```HTTP
HTTP/1.1 201 Created
Content-Type: application/json
Content-Length: 34
Location: /members/100

{
	"username": "young",
	"age": 20
}
```

상태코드 201은 Location을 포함한다.



#### 요청 데이터를 어떻게 처리한다는 뜻일까?



* 예를 들어 POST는 다음과 같은 기능에 사용된다.
  * HTML 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공
    * ex) HTML form에 입력한 정보로 회원 가입, 주문 등에서 사용
  * 게시판, 뉴스, 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시
    * ex) 게시판 글쓰기, 댓글 달기
* 정리 : 이 **리소스 URI에 POST 요청이오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 함**
  * 정해진 것이 없다.



#### POST 정리

1. **주로 새 리소스 생성(등록)하는데 사용**
   * 서버가 아직 식별하지 않은 새 리소스 생성
2. **요청 데이터 처리**
   * 단순히 데이터를 생성하거나 변경하는 것을 넘어서 프로세스를 처리해야 하는 경우
   * 주문에서 결제완료 배달시작 배달완료 처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우
   * POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음
     * ex) POST /orders/{orderId}/start-delivery {**컨트롤 URI**}
     * 실무에서 리소스 만으로 API 설계하기 어려움. 따라서 위와같이 행동과 같은 URI 를 만들 수 있는데 이를 컨트롤 URI 라고한다.
3. **다른 메서드로 처리하기 애매한 경우**
   * ex) JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우
   * 애매하면 POST로 넘길 수 있다.



## PUT, PATCH, DELETE

### PUT

* **리소스를 대체**

  * 리로스가 있으면 대체
  * 리소스가 없으면 생성
  * 쉽게 이야기해서 덮어버림 (완전히 대체함)

* **💥클라이언트가 리소스를 식별**

  * **클라이언트가** 리소스 위치를 알고 **URI 지정** 

    * ```HTTP
      PUT /members/100 HTTP/1.1
      Content-Type: application/json
      
      {
      	"username": "hello",
      	"age": 20
      }
      ```

    * 위에서 보이는 것처럼 members의 100번째 요소를 덮을 것을 명령하고 있다. 기존의 POST에서는 members로 보내면 서버에서 알아서 위치를 정해서 넣어준다.

  * 이것이 POST와의 차이점이다.



#### PUT 리소스가 있는 경우

리소스를 대체하는데 **완전히** 대체한다.

기존의 /members/100의 데이터가 다음과 같을 경우

```json
// /members/100{  "username": "young",  "age": 20}
```

아래처럼 username 필드를 적어주지 않을 경우에는 `"username"` 필드가 아예 사라진다.

```HTTP
PUT /members/100 HTTP/1.1Content-Type: application/json{	"age": 50}
```

따라서 결과는 다음처럼 대체된다.

```json
//  /members/100{  "age": 50}
```



PUT은 리소스를 수정하기 어려움 이러한 번거로움을 없애기 위해 **PATCH** 메서드를 이용한다.



### PATCH

* 리소스를 부분 변경



위에서 처럼 같은 내용을 `PATCH` 메서드로 전송할 경우 부분적으로 `"age"` 의 값만 변경이 된다.

하지만 PATCH가 지원이 안되는 경우가 있다.. 이럴 경우에는 `POST` 메서드 사용

**POST 메서드는 무적이다!** 하지만 경우에 따라 잘.. 쓰자 ^~^



### DELETE

* 리소스를 제거할 때 사용



## HTTP 메서드의 속성



### 안전(Safe Methods)

* 호출해도 리소스를 변경하지 않는다.
* GET 같은 경우 안전한 메서드 (단순 조회)
* 호출 했을때 **리소스에 변경이 없으면 안전**하다고 할 수 있다.



### 멱등 (Idempotent Methods)

* f(f(x)) = f(x)

* 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다.

* 멱등 메서드

  * GET: 한 번 조회하든, 두 번 조회하든 같은 결과가 조회된다.
  * PUT: 결과를 대체한다. 따라서 같은 요청을 여러번 해도 최종 결과는 같다.
  * DELETE: 결과를 삭제한다. 같은요청을 여러번 해도 삭제된 결과는 똑같다.
  * <span style="color:red">POST</span>: 멱등이 아님. 두 번 호출하면 같은 **결제가 중복해서 발생**할 수 있다.

* 활용 (왜 필요한지??)

  * 자동 복구 메커니즘
  * ex) DELETE 호출했는데 서버에서 응답이 없을 경우 클라이언트에서 자동으로 재요청을 할 수 있다.

  

* **Q: 재요청 중간에 다른 곳에서 리소스를 변경해버리면?**

  * 1. GET -> username: A, age:20
    2. PUT -> username: A, age:30
    3. GET -> username: A, age:30 -> 2번째 프로세스에 의해 바뀐 데이터 조회

* **A: 멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다.**





### 캐시가능 (Cacheable Methods)

* 응답 결과 리소스를 캐시해서 사용해도 되는가?
  * 웹 브라우저의 IMG를 다운받는 경우 로컬 PC 브라우저에서 저장
* GET, HEAD, POST, PATCH 캐시가능
* 실제로는 GET, HEAD 정도만 캐시로 사용
  * POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음.
* 실무에서는 거의 GET 만 캐시로 사용한다고 보면 된다.

