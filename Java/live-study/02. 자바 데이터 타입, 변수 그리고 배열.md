# live study Week2 : 자바 데이터 타입, 변수 그리고 배열

## 목표 

자바의 프리미티브(원시) 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.



## 학습할 것 

- [프리미티브 타입 종류와 값의 범위 그리고 기본 값](#프리미티브-타입-종류와-값의-범위-그리고-기본-값)
- [프리미티브 타입과 레퍼런스 타입](#프리미티브-타입과-레퍼런스-타입)
- [리터럴](#리터럴)
- [변수 선언 및 초기화하는 방법](#변수-선언-및-초기화하는-방법)
- [변수의 스코프와 라이프타임](#변수의-스코프와-라이프타임)
- [타입 변환, 캐스팅 그리고 타입 프로모션](#타입-변환,-캐스팅-그리고-타입-프로모션)
- [1차 및 2차 배열 선언하기](#1차-및-2차-배열-선언하기)
- [타입 추론, var](#타입-추론,-var)



### 프리미티브 타입 종류와 값의 범위 그리고 기본 값

|  종류  | 데이터형 | 크기(byte / bit) | 기본 값 | 표현 범위                                                    |
| :----: | -------- | ---------------- | ------- | ------------------------------------------------------------ |
| 논리형 | boolean  | 1 / 8            | false   | true 또는 false                                              |
| 문자형 | char     | 2 / 16           | \u0000  | '\u0000' ~ 'uFFFF' (16비트 유니코드 문자 데이터)             |
| 정수형 | byte     | 1 / 8            | 0       | -128 ~ 127                                                   |
| 정수형 | short    | 2 / 16           | 0       | -32768 ~ 32767                                               |
| 정수형 | int      | 4 / 32           | 0       | -2147483648 ~ 2147483647( -21억 ~ + 21억)                    |
| 정수형 | long     | 8 / 64           | 0L      | -9223372036854775808 ~ 9223372036854775807(-100경 ~ + 100경) |
| 실수형 | float    | 4 / 32           | 0.0F    | 1.4E-45 ~ 3.4028235E38                                       |
| 실수형 | double   | 8 / 64           | 0.0     | 4.9E-324 ~ 1.7976931348623157E308                            |

* boolean
  * **Java가 데이터를 다루는 최소단위가 Byte 이기 때문에 크기는 1Byte가 된다.**
* char
  * Java의 경우 Unicode를 사용, 2Byte를  사용한다
  * **Java에서 유일하게 제공되는 unsigned**
* float
  * `float data = 3.14F` or `float data = 3.14f`
  * F를 붙여주지 않으면 `double` 데이터로 인식한다.
* double
  * `double data = 1e-3;` == 0.001 (1 에 대해 10의 -3승)



### 프리미티브 타입과 레퍼런스 타입

* `원시 타입`은 정수, 실수, 문자, 논리 리터럴등의 **실제 데이터 값을 저장하는 타입**이고,

* `참조 타입`은 객체(Object)의 번지를 참조(주소를 저장)하는 타입으로 **메모리 번지 값을 통해 객체를 참조하는 타입**이다.

* `참조 타입`은 **원시 타입을 제외한 타입들(문자열, 배열, 열거, 클래스, 인터페이스)**을 말한다.

Java에서 **`실제 객체`는 `힙 영역`에 저장**되며 **`참조 타입 변수`는 `스택 영역`에 실제 객체들의 주소를 저장**하여, 객체를 사용할때 마다 **참조 변수에 저장된 객체의 주소를 불러와 사용하는 방식**이다.

* Example

|                          스택 영역                           |      힙 영역       |
| :----------------------------------------------------------: | :----------------: |
| int age = 25<br />char cc = 'c'<br />String name = 10101번지 | 10101번지 : "커피" |



* **정적 메모리 스택(Stack) 영역**
  * 스택 영역에는 기본타입 변수가 할당되고 변수의 실제 값들이 저장된다.
  * 참조 타입의 변수들은 이 **스택 영역에서 힙 영역에 생성된 객체들의 주소 값을 저장**하고 있는다.
  * 객체 안의 메소드의 작업이 종료되면 할당되었던 메모리 공간은 반환되어 비워진다.
* **동적 메모리 힙(Heap) 영역**
  * 힙 영역에는 객체와 배열이 생성된다.
  * 참조타입 (문자열, 배열, 클래스, 인터페이스 등)들이 **객체들의 주소 를 스택 영역에 저장**한다.
  * 원시타입의 변수들과 다르게 크기가 정해져 있지 않다.
  * 프로그램 실행시 메모리에 동적으로 할당되며 참조하는 변수가 없으면 자바의 가비지 컬렉터가 제거한다.



### 리터럴

리터럴(literal)이란 그 자체로 값을 의미하는 데이터이다.

즉, 변수와 상수와는 달리 데이터가 저장된 메모리 공간을 가리키는 이름을 가지고 있지 않음

```java
int var = 30; // 여기서 30이 리터럴 임
final int AGES = 100; // 100이 리터럴 임
```

타입에 따라 정수형 리터럴, 실수형 리터럴, 논리형 리터럴, 문자형 리터럴, 문자열 리터럴, null 리터럴 등으로 부른다



### 변수 선언 및 초기화하는 방법

변수를 선언하는 방법은 자료형과 변수명을 적어주면 선언이 된다. 초기값 (기본 값)은 위의 원시타입에 적어놓은 것과 같다.

초기화는 자료형과 변수명 그리고 할당을 동시에 해주면 된다.

```java
int a; // 10진 정수형 변수 a 선언
int b = 10; // 10진 정수형 변수 b를 10으로 초기화
```



### 변수의 스코프와 라이프타임

다음과 같이 변수를 선언한다고 가정해보자.

```java
public class Test {
  int var1;
}
```

이 변수의 사용범위는 선언된 클래스의 중괄호 내에서 사용가능하다. 이런 범위를 우리가 **'스코프'**라고 부르는 것이다.

다음 내용을 보자.

```java
public class Test {
  int var1;
  
  void foo() {
    int var2;
  }
}
```

이러한 경우 var1은  `foo()` 메서드 안에서도 사용할 수 있다. 하지만 **var2**는 `foo()` 메서드의 중괄호 내에서만 사용할 수 있다. 이것은 중괄호에만 해당하는 내용이 아니다. 다음내용을 확인하자.

```java
public class Test {
  int var1;
  
 void foo() {
   if (var1 == 0) {
     int var3 = 100;
     var1 = var3;
   }
 }
}
```

위의 경우 조건문인 if 안에서 새로운 정수형 변수 `var3`을 100으로 초기화 한다. 이 경우 **if의 스코프를 빠져나오게 되면 var3에는 접근 및 사용이 불가능하게 된다.** 이를 **생명주기** 라고한다.



#### 생명주기 (LifeCycle)

각 변수의 생명 주기에 대해 알아보자.

![image](https://user-images.githubusercontent.com/52594760/140444966-414e79eb-0521-4b02-874c-76a7a1b2f266.png)

* 인스턴스 변수(전역 변수) : 객체가 생성될 때, 변수가 생성된다. 즉, 현재 Test 클래스를 static main 메소드나 다른 클래스에서 인스턴스를 생성할때 같이 생성된다. 그리고 인스턴스는 참조가 없을 때 가비지 컬렉터가 객체를 지워버리게 되는데, 이 때 인스턴스 변수도 같이 소멸된다.
* 정적 변수(클래스 변수) : **클래스가 처음 호출 되면서 생성이 되고, 자바 어플리케이션이 종료되는 시점에 같이 소멸된다.**
* 매개 변수(파라미터) : `foo()` 메서드가 호출 될 때 var3가 생성되고 `foo()`메서드가 종료시점에 var3도 소멸된다.
* 지역 변수 : `{` 가 시작되는 시점에 생성되며, `}` 로 끝나는 시점에 소멸된다.





### 타입 변환, 캐스팅 그리고 타입 프로모션

참고자료 : [자바 형변환(Casting, Promotion)과 바인딩(Binding)](https://webdevtechblog.com/%EC%9E%90%EB%B0%94-%ED%98%95%EB%B3%80%ED%99%98-casting-promotion-%EA%B3%BC-%EB%B0%94%EC%9D%B8%EB%94%A9-binding-ef3e453eb8a6)

자바에서의 형 변환은 크게 **명시적 형변환(Casting)**, **묵시적 형변환(Promotion)**이 존재한다. 형 변환에 대해 자세하게 알아야 상속에 대해서도 더 자세하게 이해할 수 있다.



#### 명시적 형변환 (Casting)

**큰 타입이 작은 타입으로 변환**되는 형태이다.

**원시 타입**의 경우 다음과 같이 데이터 앞에 타입을 따로 명시하면 바꿀 수 있다.

```java
int a;
float b = 1.1f;
a = (int)b;
//expected output : 1
```



**--- 이부분은 상속관련개념에 대해 공부하고 추가기술 ---**

**객체 Casting**

```java
// Child 클래스는 Parent클래스를 상속받고 있다고 가정
public void casting(Parent parent) {
  if (parent instanceof Child) {
    Child child = (Child) parent; // Casting
  }
}
```

객체간 Casting을 하기 위해서 항상 `instanceof` 를 사용하여 상속 관계에 있는지 확인해야 한다. 상속 관계에 있지 않은 객체를 형변환 하려고 하면 에러가 발생한다.



#### 묵시적 형변환 (Promotion)

**작은 타입이 큰 타입으로 변환** 되는 형태이다. 작은 타입이 큰 타입으로 변환될 때 데이터 앞에 따로 타입을 명시하지 않아도 된다.

```java
int a = 2;
float b;
b = a;
// expected output : 2.0f;
```



**객체 Promotion**

```java
// Child 는 Parent Class를 상속받고 있다고 가정
Parent parent = new Child();
```

여기서  `parent` 객체는 `Stack` 메모리 에 저장, `new` 키워드로 생성한 `Child` 객체는 `Heap` 메모리에 저장되고 `parent` 는 힙 영역의 `Child`를 가리킨다.

나중에 **다형성**, **함수 오버라이딩** 등에 대해 공부하고 **동적 바인딩 과 정적 바인딩 개념에 대해 추가 기술할 것**



### 1차 및 2차 배열 선언하기

우선 배열이란 같은 자료형의 데이터를 담을 수 있는 바구니 라고 생각하자. 배열을 선언하는 방법은 다음과 같다.

```java
int[] intArr = {1, 2, 3, 4}; // 1차원 배열 선언 및 초기화

int[][] intArr2 = { // 2차원 배열 선언 및 초기화
  {1, 2},
  {3, 4}
};

// 각 원소에 접근하는 방법은 다음과 같다.
int firstElement = intArr[0]; // 1

int secondElement = intArr2[1][1]; // 4
```





### 타입 추론, var

jdk 10 이상부터 type-inference(타입추론)이 가능하다.

#### 타입추론 이란

말그대로 개발자가 변수의 타입을 명시적으로 적어주지 않고도 **컴파일러가 알아서** 해당 변수의 타입을 대입된 리터럴로 추론하는 것이다.

```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in))
var line = 
```



#### var는 초기값이 있는 지역변수

* var은 멤버변수 또는 메서드의 파라미터, 리턴타입 등으로 사용이 불가능하다.
* 선언과 동시에 값의 할당(초기화)이 이루어져야 하는데 그렇지 않을 경우 사용이 불가능하다.
* 그럼 왜 사용할까?? 다음 예시를 확인하자

```java
public class Test {
  public static void main(String[] args) {
    Map<String, Integer> map1 = new HashMap<>();
    
    var map2 = new HashMap<>();
  }
}
```

같은 HashMap 객체를 생성하는데 타이핑을 해야하는 코드의 양이 다르다. 

이런 경우 var의 사용이 용이할 수 있겠으나 결론적으로 말하면 코드를 해석할 때 우리는 변수의 타입에 대해 한번 더 생각해봐야한다. 혹은 변수의 이름에 타입을 추론하면서 네이밍을 엄청 잘해야한다.



#### var은 런타임 오버헤드가 없다.

컴파일 시점에서 var에 초기화된 값을 보고 추론에서 바이트코드에서 명시적으로 타입을 변환하기 때문에 타입 추론 변수를 읽을 때마다  타입을 알아내기 위한 연산을 하지 않는다는 것이다.

* 해당 이유 때문에 var로 선언된 변수는 중간에 타입이 **절대** 변경되지 않는다. (Java 한정)



