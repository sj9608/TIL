### React useCallback

메모이제이션된 콜백을 반환한다. 보통 메모이제이션된 버전은 콜백의 의존성이 변경되었을 때만 변경되는데. 이것으로 불필요한 렌더링을 방지하기 위해(ex : `shouldComponentUpdate`) 참조의 동일성에 의존적인 최적화된 자식 컴포넌트에 콜백을 전달할 때 유용하다  

`useCallbaack(fn, deps)` 는 `useMemo(() => fn, deps)` 와 같다.

```tsx
const memoizedCallback = useCallback(
	() => {
    doSmoething(a, b);
  },
	[a, b],
)
```

`useCllback(fn, deps)` 

의존성 배열인 deps에 변경을 감지해야할 값을 넣어주게 되면 그 값이 변경될 때마다 콜백 함수를 새로 생성하게 된다.

#### 왜 사용하는가

컴포넌트에 정의된 일반 함수들은 컴포넌트가 리렌더링 될 때 마다 새로 만들어진다. 또한 리렌더링의 조건은 다음과 같다.

* props가 변경되었을 때
* state가 변경되었을 때
* 부모 컴포넌트가 렌더링 되었을 때
* forceUpdate() 를 실행하였을 때

이러한 리렌더링을 성능에 영향을 줄 수 있기 때문에 `useCallback()` 을 사용해 컴포넌트가 리렌더링 되더라도 **그 함수가 의존하는 값들이 바뀌지 않는 한 기존 함수를 계속해서 반환하게** 함으로 써 성능최적화에 도움을 줄 수 있다.

함수를 선언하는 것 자체는 메모리, CPU 리소스를 많이 차지하는 작업은 아니기 때문에 함수를 새로 선언한다고 해서 그 자체만으로 큰 부하가 생길일은 없지만, 한번 만든 함수를 필요할때만 새로 만들고 재사용하는 것은 중요하다.

##### 자바스크립트 함수 동등성

`useCallback()` hook 함수를 언제 사용해야하는지 제대로 이해하려면 먼저 자바스크립트에서 함수 간의 동등함이 어떻게 결정되는지 알 필요가 있다.

브라우저 콘솔을 열고 다음과 같이 동일한 코드의 자바스크립트 함수가 동일한지 `===` 연산자를 통해 비교해보면 `false` 가 반환될 것이다.

```js
const add1 = () => x + y;
const add2 = () => x + y;
add1 === add2
// false
```

자바스크립트에서  **함수도 객체**로 취급이 되기 때문에 메로리 주소에 의한 참조비교가 일어나기 때문에 이러한 결과가 나타나는 것이다. 

**이러한 JS의 특성은 React 컴포넌트 함수 내에서 어떤 함수를 다른 함수의 인자로 넘기거나 자식 컴포넌트의 prop으로 넘길 때 예상치 못한 성능 문제로 이어질 수 있다.**



